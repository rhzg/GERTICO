/*******************************************************************************
**
** Copyright (c) Fraunhofer IITB
** All rights reserved.
**
********************************************************************************
**

$Author: mul $
$Name $
$Log: RegisteredObject.cpp,v $
Revision 1.45  2009/09/23 06:48:13  mul
Add deleted objects.

Revision 1.44  2009/06/02 12:04:11  mul
Add acquiring federates to save / restore data.

Revision 1.43  2008/11/17 15:25:09  mul
Changes for logging.

Revision 1.42  2007/09/25 08:01:21  mul
Changes for ddm.

Revision 1.41  2007/09/05 15:14:42  mul
Changes for ieee1516.

Revision 1.40  2007/06/28 10:13:33  mul
Add new methods.

Revision 1.39  2007/05/03 14:30:26  mul
Add wchar parameter to exception constructor.

Revision 1.38  2007/03/06 09:26:56  mul
Changes for ieee conversion.

Revision 1.37  2007/02/02 13:22:57  mul
Fix some memory leaks.

Revision 1.36  2007/01/09 09:55:21  mul
Clean up some program code.

Revision 1.35  2006/12/15 08:41:46  mul
Add function.

Revision 1.34  2006/11/15 11:08:22  mul
Changes for phase 2 testcases.

Revision 1.33  2006/10/18 11:31:08  mul
Minor changes to fix create federation execution problems.

Revision 1.32  2006/10/12 13:47:39  mul
Changes for verification test.

Revision 1.31  2006/10/05 15:01:52  hzg
release request

Revision 1.30  2006/09/21 14:45:29  mul
Remove unused methods.

Revision 1.29  2006/08/30 11:37:36  mul
Add federate holder class.

Revision 1.28  2006/08/23 11:13:16  mul
Changes for phase 4 testcases.

Revision 1.27  2006/08/18 12:54:29  mul
Changes for phase 4 testcases.

Revision 1.26  2006/08/15 12:35:33  mul
Changes for phase 4 tests.

Revision 1.25  2006/08/08 14:08:14  mul
Move named object map to registered object.

Revision 1.24  2006/08/01 11:20:54  mul
Changes in object handling and mapping.

Revision 1.23  2006/06/28 14:11:51  mul
Remove unused method.

Revision 1.22  2006/06/23 13:03:46  mul
Refine region logic.

Revision 1.21  2006/05/23 11:32:44  mul
Remove internal logic between declaration and ownership management.

Revision 1.20  2006/05/22 11:41:01  mul
Add object id to print information.

Revision 1.19  2006/05/17 06:37:36  mul
Minor changes.

Revision 1.18  2006/05/09 13:19:51  hzg
new attribute state "acquired" introduced

Revision 1.17  2006/03/17 11:29:57  mul
Fix scope logic for data distribution.

Revision 1.16  2006/02/27 14:28:46  mul
Change handling of attribute/region pairs.

Revision 1.15  2006/02/09 15:33:04  mul
Removed an enum value.

Revision 1.14  2006/02/08 14:03:24  mul
Added a const qualifier for a method.

Revision 1.13  2005/12/19 15:46:15  mul
Minor changes.

Revision 1.12  2005/08/22 14:12:23  mul
Add some helper functions.

Revision 1.11  2005/03/02 08:39:22  mul
Change for verfication test.

Revision 1.10  2005/02/11 14:46:34  mul
Add scoping.

Revision 1.9  2005/02/09 07:39:25  mul
Scoping added for std.

Revision 1.8  2005/02/07 10:34:01  mul
Changes due to test cases.

Revision 1.7  2005/01/28 08:42:37  hzg
merging gertico_0_16b_fix into main thread

Revision 1.6  2004/12/13 15:52:40  mul
One function only for retrieving ownership attributes.

Revision 1.5.2.1  2005/01/27 10:22:31  hzg
bug fix concerning include and std usage
requred for using ACE-5.4+TAO-1.4

Revision 1.5  2004/09/23 14:57:08  mul
Changes for save federation.

Revision 1.4  2004/08/19 09:35:50  mul
Changes for save/restore logic.

Revision 1.3  2004/07/16 10:28:17  mul
Changes due to verfication test.

Revision 1.2  2004/05/28 11:20:53  mul
Remove unused variable.

Revision 1.1  2004/05/27 11:22:15  mul
Integrate subscriber management.


**
*******************************************************************************/


/* -*- C++ -*- $Id: RegisteredObject.cpp,v 1.45 2009/09/23 06:48:13 mul Exp $ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "RegisteredObject.h"
#include "Util/Mapper.h"
#include "Util/NextHandle.h"

#include <iostream>

// Static strings for save/restore.
std::string GERTICO::RegisteredObjectsHolder::classStr("class");
std::string GERTICO::RegisteredObjectsHolder::idStr("id");
std::string GERTICO::RegisteredObjectsHolder::nameStr("name");

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::AttInfo::AttInfo (void)
{
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::AttInfo::~AttInfo (void)
{
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GeRtiFactory::GeRtiHandle GERTICO::AttInfo::getStatus(void)
{
  return status;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttInfo::setStatus(GeRtiFactory::GeRtiHandle const &theStatus)
{
  status = theStatus;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::AttributeInfo::AttributeInfo (void)
{
  status = undefined;
  federate = 0;
  orderTypeDefault = 0;
  orderType = orderTypeDefault;
  transportationTypeDefault = 0;
  transportationType = transportationTypeDefault;
  init ();
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::AttributeInfo::AttributeInfo (GeRtiFactory::GeRtiHandle const &theFederate, AttributeStatus const &s, GeRtiFactory::GeRtiHandle const &theOrderTypeDefault, GeRtiFactory::GeRtiHandle const &theTransportationTypeDefault)
{
  status = s;
  federate = theFederate;
  orderTypeDefault = theOrderTypeDefault;
  orderType = orderTypeDefault;
  transportationTypeDefault = theTransportationTypeDefault;
  transportationType = transportationTypeDefault;
  addPreviousOwner(theFederate);
  init ();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::addAcquiringFederate (GeRtiFactory::GeRtiHandle const &theFederate)
{
  acquiringFederates.insert (theFederate);
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::addPreviousOwner(GeRtiFactory::GeRtiHandle const &theFederate)
{
  GERTICO::HandleSet::iterator itPreviousOwner;

  if (theFederate)
  {
    itPreviousOwner = previousOwners.find(theFederate);
    if (itPreviousOwner == previousOwners.end())
    {
      previousOwners.insert(theFederate);
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::removeAcquiringFederate (GeRtiFactory::GeRtiHandle const &theFederate)
{
  GERTICO::HandleSet::iterator iAF;
  iAF = acquiringFederates.find (theFederate);
  if (iAF != acquiringFederates.end())
  {
    acquiringFederates.erase(iAF);
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
bool GERTICO::AttributeInfo::testIfFederateIsAcquiring (GeRtiFactory::GeRtiHandle const &theFederate)
{
  GERTICO::HandleSet::iterator iAF;
  iAF = acquiringFederates.find (theFederate);
  if (iAF != acquiringFederates.end())
  {
    return true;
  }
  else
  {
    return false;
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GeRtiFactory::GeRtiHandle GERTICO::AttributeInfo::getFirstAcquiringFederate ()
{
  GERTICO::HandleSet::iterator iAF;
  iAF = acquiringFederates.begin ();
  if (iAF != acquiringFederates.end())
  {
    return *iAF;
  }
  else
  {
    throw GeRtiFactory::RTIinternalError(L"missing acquiring federate");
  }
}



// ---------------------------------------------------------------------------
// If a non zero region is added, the zero region entry must be deleted for
// this federate.
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::addRegion(GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &theRegion)
{
  GERTICO::HandleSet::iterator itFederate;
  GERTICO::HandleSetMap::iterator itRegionFederate;

  if (theRegion != 0)
  {
    // Take care of the default region
    itRegionFederate = regionFederates.find(0);
    if (itRegionFederate != regionFederates.end())
    {
      itFederate = itRegionFederate->second.find(theFederate);
      if (itFederate != itRegionFederate->second.end())
      {
        itRegionFederate->second.erase(itFederate);
      }
    }
  }

  itRegionFederate = regionFederates.find(theRegion);
  if (itRegionFederate != regionFederates.end())
  {
    GERTICO::HandleSet *federatesPtr;
    federatesPtr = &itRegionFederate->second;
    itFederate = federatesPtr->find(theFederate);
    if (itFederate == federatesPtr->end())
    {
      federatesPtr->insert(theFederate);
    }
  }
  else
  {
    GERTICO::HandleSet federates;
    federates.insert(theFederate);
    regionFederates[theRegion] = federates;
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::associateRegion(GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &theRegion)
{
  GERTICO::HandleSet::iterator itPreviousOwner;

  if (theFederate)
  {
    itPreviousOwner = previousOwners.find(theFederate);
    if (itPreviousOwner == previousOwners.end())
    {
      addRegion(theFederate, theRegion);
    }
  }
}

// ---------------------------------------------------------------------------
// See pre-conditions for publishObjectClass
// ---------------------------------------------------------------------------
bool GERTICO::AttributeInfo::beingAcquired (void)
{
  if ((status == acquiring) || (status == acquired))
  {
    return true;
  }

  return false;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::changeOrderType (GeRtiFactory::GeRtiHandle const &theOrderType)
{
  orderType = theOrderType;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::changeTransportationType (GeRtiFactory::GeRtiHandle const &theTransportationType)
{
  transportationType = theTransportationType;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::clearFederateRegion(GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &theRegion)
{
  GERTICO::HandleSet::iterator itFederate;
  GERTICO::HandleSetMap::iterator itRegion;
  bool gotFederateRegion = false;
  bool gotNonZeroRegion = false;

  // Do not clear the default region.
  if (theRegion == 0)
  {
    return;
  }

  // Remove the region for the federate.
  itRegion = regionFederates.find(theRegion);
  if (itRegion != regionFederates.end())
  {
    itFederate = itRegion->second.find(theFederate);
    if (itFederate != itRegion->second.end())
    {
      itRegion->second.erase(itFederate);
      gotFederateRegion = true;
    }
  }

  // If an old region was deleted, check if any federate regions exist, else put into default region
  if (gotFederateRegion)
  {
    // Check if any non-zero federate region exists
    for (itRegion = regionFederates.begin(); itRegion != regionFederates.end(); itRegion++)
    {
      if (itRegion->first == 0)
      {
        continue;
      }

      itFederate = itRegion->second.find(theFederate);
      if (itFederate != itRegion->second.end())
      {
        gotNonZeroRegion = true;
        break;
      }
    }

    // Add to default region
    if (gotNonZeroRegion == false)
    {
      itRegion = regionFederates.find(0);
      if (itRegion != regionFederates.end())
      {
        itRegion->second.insert(theFederate);
      }
      else
      {
        GERTICO::HandleSet federates;
        federates.insert(theFederate);
        regionFederates[0] = federates;
      }
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::clearFederateRegions(GeRtiFactory::GeRtiHandle const &theFederate)
{
  GERTICO::HandleSet regions;
  GERTICO::HandleSet::iterator itRegion;

  getFedRegions(theFederate, regions);

  for (itRegion = regions.begin(); itRegion != regions.end(); itRegion++)
  {
    clearFederateRegion(theFederate, *itRegion);
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::delRegion(GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &theRegion)
{
  GERTICO::HandleSet::iterator itFederate;
  GERTICO::HandleSetMap::iterator itRegionFederate;

  itRegionFederate = regionFederates.find(theRegion);
  if (itRegionFederate != regionFederates.end())
  {
    GERTICO::HandleSet *federatesPtr;
    federatesPtr = &itRegionFederate->second;
    itFederate = federatesPtr->find(theFederate);
    if (itFederate != federatesPtr->end())
    {
      federatesPtr->erase(itFederate);
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::getAllRegions(GERTICO::HandleSet &theRegions)
{
  GERTICO::HandleSetMap::iterator itRegion;

  for (itRegion = regionFederates.begin(); itRegion != regionFederates.end(); itRegion++)
  {
    theRegions.insert(itRegion->first);
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GeRtiFactory::GeRtiHandle GERTICO::AttributeInfo::getFederate (void)
{
  return federate;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GeRtiFactory::GeRtiHandle GERTICO::AttributeInfo::getOrderType (void)
{
  return orderType;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::getFedRegions(GeRtiFactory::GeRtiHandle const &theFederate, GERTICO::HandleSet &theRegions)
{
  GERTICO::HandleSet::iterator itFederate;
  GERTICO::HandleSetMap::iterator itRegionFederate;

  theRegions.clear();

print();
  for (itRegionFederate = regionFederates.begin(); itRegionFederate != regionFederates.end(); itRegionFederate++)
  {
    itFederate = itRegionFederate->second.find(theFederate);
    if (itFederate != itRegionFederate->second.end())
    {
      theRegions.insert(itRegionFederate->first);
    }
  }
print();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::getOwner(GeRtiFactory::GeRtiHandle &theOwner)
{
  theOwner = federate;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::AttributeStatus GERTICO::AttributeInfo::getStatus(void)
{
  return status;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GeRtiFactory::GeRtiHandle GERTICO::AttributeInfo::getTransportationType (void)
{
  return transportationType;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::init (void)
{
  acquiringFederateStr = "acquiringFederate";
  acquiringFederatesStr = "acquiringFederates";
  federateStr = "federate";
  idStr = "id";
  orderTypeStr = "orderType";
  regionStr = "region";
  regionsStr = "regions";
  statusStr = "status";
  unsetRequested ();
  transportationTypeStr = "transportationType";
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
bool GERTICO::AttributeInfo::ownedByFederate (GeRtiFactory::GeRtiHandle const &theFederate)
{
  if (federate == theFederate)
  {
    // Special case.
    if (federate == 0)
    {
      return true;
    }

    // General case.
    if (status == owned || status == acquiring ||  status == acquired || status == divesting || status == divestConfirm)
    {
      return true;
    }
  }

  return false;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::print(void)
{
/*
  GERTICO::HandleSet *federateSetPtr;
  GERTICO::HandleSet::iterator itFederate;
  GERTICO::HandleSetMap::iterator itRegionFederates;
  unsigned long ul;

  std::cout << "regionFederates " << std::endl;
  for (itRegionFederates = regionFederates.begin(); itRegionFederates != regionFederates.end(); itRegionFederates++)
  {
    ul = itRegionFederates->first;
    std::cout << "AttributeInfo region " << ul << std::endl;
    federateSetPtr = &itRegionFederates->second;
    for (itFederate = federateSetPtr->begin(); itFederate != federateSetPtr->end(); itFederate++)
    {
      ul = *itFederate;
      std::cout << "AttributeInfo Federate " << ul << std::endl;
    }
  }
  std::cout << std::endl;
*/
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::restore (DOMElement &theDOMElement)
{
  DOMNode* child;
  DOMNode* subChild;
  GERTICO::HandleSet::iterator itFederate;
  GERTICO::HandleSetMap::iterator itRegionFederate;
  char *tmpChar;
  unsigned long tmpFederate;
  unsigned long tmpRegion;
  unsigned long tmpUL;

  tmpChar = XMLString::transcode (theDOMElement.getAttribute (XMLString::transcode (federateStr.c_str ())));
  sscanf (tmpChar, "%lu", &tmpUL);
  federate = tmpUL;
  XMLString::release(&tmpChar);
  tmpChar = XMLString::transcode (theDOMElement.getAttribute (XMLString::transcode (orderTypeStr.c_str ())));
  if (strcmp (tmpChar, "timestamp") == 0)
  {
    orderType = 1;
  }
  else
  {
    orderType = 0;
  }

  for (child = theDOMElement.getFirstChild(); child != 0; child = child->getNextSibling())
  {
    if (child->getNodeType() == DOMNode::ELEMENT_NODE)
    {
      if (XMLString::compareString(child->getNodeName(),XMLString::transcode(acquiringFederatesStr.c_str())) == 0)
      {
        for (subChild = child->getFirstChild(); subChild != 0; subChild = subChild->getNextSibling())
        {
          if (subChild->getNodeType() == DOMNode::ELEMENT_NODE)
          {
            if (XMLString::compareString(subChild->getNodeName(),XMLString::transcode(acquiringFederateStr.c_str())) == 0)
            {
              tmpChar = XMLString::transcode (((DOMElement*)subChild)->getAttribute (XMLString::transcode (acquiringFederateStr.c_str ())));
              sscanf (tmpChar, "%lu", &tmpUL);
              acquiringFederates.insert (tmpUL);
            }
          }
        }
      }
      if (XMLString::compareString(child->getNodeName(),XMLString::transcode(regionsStr.c_str())) == 0)
      {
        for (subChild = child->getFirstChild(); subChild != 0; subChild = subChild->getNextSibling())
        {
          if (subChild->getNodeType() == DOMNode::ELEMENT_NODE)
          {
            if (XMLString::compareString(subChild->getNodeName(),XMLString::transcode(regionStr.c_str())) == 0)
            {
              XMLString::release(&tmpChar);
              tmpChar = XMLString::transcode(((DOMElement*)subChild)->getAttribute(XMLString::transcode(idStr.c_str())));
              sscanf(tmpChar, "%lu", &tmpRegion);
              XMLString::release(&tmpChar);
              tmpChar = XMLString::transcode(((DOMElement*)subChild)->getAttribute(XMLString::transcode(federateStr.c_str())));
              sscanf(tmpChar, "%lu", &tmpFederate);
              itRegionFederate = regionFederates.find(tmpRegion);
              if (itRegionFederate != regionFederates.end())
              {
                GERTICO::HandleSet *federatesPtr;
                federatesPtr = &itRegionFederate->second;
                itFederate = federatesPtr->find(tmpFederate);
                if (itFederate == federatesPtr->end())
                {
                  federatesPtr->insert(tmpFederate);
                }
              }
              else
              {
                GERTICO::HandleSet federates;
                federates.insert(tmpFederate);
                regionFederates[tmpRegion] = federates;
              }
            }
          }
        }
      }
    }
  }

  XMLString::release(&tmpChar);
  tmpChar = XMLString::transcode (theDOMElement.getAttribute (XMLString::transcode (statusStr.c_str ())));
  if (strcmp (tmpChar, "unowned") == 0)
  {
    status = unowned;
  }
  if (strcmp (tmpChar, "owned") == 0)
  {
    status = owned;
  }
  if (strcmp (tmpChar, "acquiring") == 0)
  {
    status = acquiring;
  }
  if (strcmp (tmpChar, "acquired") == 0)
  {
    status = acquired;
  }
  if (strcmp (tmpChar, "divesting") == 0)
  {
    status = divesting;
  }
  if (strcmp (tmpChar, "divestConfirm") == 0)
  {
    status = divestConfirm;
  }
  if (strcmp (tmpChar, "undefined") == 0)
  {
    status = undefined;
  }
  XMLString::release(&tmpChar);
  tmpChar = XMLString::transcode (theDOMElement.getAttribute (XMLString::transcode (transportationTypeStr.c_str ())));
  if (strcmp (tmpChar, "best_effort") == 0)
  {
    transportationType = 1;
  }
  else
  {
    transportationType = 0;
  }
  XMLString::release(&tmpChar);
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::save(DOMDocument &theDOMDocument, DOMElement &theDOMElement)
{
  DOMElement* elemLevel1;
  DOMElement* elemLevel2;
  GERTICO::HandleSet::iterator itFederate;
  GERTICO::HandleSetMap::iterator itRegionFederate;
  XMLCh tempStr[100];
  XMLCh tempStr1[100];
  char buf[128];
  unsigned long ul;

  XMLString::transcode(statusStr.c_str (), tempStr, 99);
  switch (status)
  {
    case unowned:
    {
      strcpy (buf, "unowned");
      break;
    }
    case owned:
    {
      strcpy (buf, "owned");
      break;
    }
    case acquiring:
    {
      strcpy (buf, "acquiring");
      break;
    }
    case acquired:
    {
      strcpy (buf, "acquired");
      break;
    }
    case divesting:
    {
      strcpy (buf, "divesting");
      break;
    }
    case divestConfirm:
    {
      strcpy (buf, "divestConfirm");
      break;
    }
    default:
    {
      strcpy (buf, "undefined");
      break;
    }
  }
  XMLString::transcode(buf, tempStr1, 99);
  theDOMElement.setAttribute(tempStr, tempStr1);

  XMLString::transcode(federateStr.c_str (), tempStr, 99);
  ul = federate;
  sprintf (buf, "%lu", ul);
  XMLString::transcode(buf, tempStr1, 99);
  theDOMElement.setAttribute(tempStr, tempStr1);

  XMLString::transcode(acquiringFederatesStr.c_str (), tempStr, 99);
  elemLevel1 = theDOMDocument.createElement(tempStr);
  theDOMElement.appendChild(elemLevel1);
  for (itFederate = acquiringFederates.begin(); itFederate != acquiringFederates.end(); itFederate++)
  {
    XMLString::transcode(acquiringFederateStr.c_str(), tempStr, 99);
    elemLevel2 = theDOMDocument.createElement(tempStr);
    elemLevel1->appendChild(elemLevel2);

    ul = *itFederate;
    sprintf (buf, "%lu", ul);
    XMLString::transcode(buf, tempStr1, 99);
    elemLevel2->setAttribute(tempStr, tempStr1);
  }

  XMLString::transcode(regionsStr.c_str(), tempStr, 99);
  elemLevel1 = theDOMDocument.createElement(tempStr);
  theDOMElement.appendChild(elemLevel1);

  for (itRegionFederate = regionFederates.begin(); itRegionFederate != regionFederates.end(); itRegionFederate++)
  {
    XMLString::transcode(regionStr.c_str(), tempStr, 99);
    elemLevel2 = theDOMDocument.createElement(tempStr);
    elemLevel1->appendChild(elemLevel2);

    XMLString::transcode(idStr.c_str (), tempStr, 99);
    ul = itRegionFederate->first;
    sprintf (buf, "%lu", ul);
    XMLString::transcode(buf, tempStr1, 99);
    elemLevel2->setAttribute(tempStr, tempStr1);

    for (itFederate = itRegionFederate->second.begin(); itFederate != itRegionFederate->second.end(); itFederate++)
    {
      XMLString::transcode(federateStr.c_str (), tempStr, 99);
      ul = *itFederate;
      sprintf (buf, "%lu", ul);
      XMLString::transcode(buf, tempStr1, 99);
      elemLevel2->setAttribute(tempStr, tempStr1);
    }
  }

  XMLString::transcode(orderTypeStr.c_str (), tempStr, 99);
  if (orderType)
  {
    strcpy (buf, "timestamp");
  }
  else
  {
    strcpy (buf, "receive");
  }
  XMLString::transcode(buf, tempStr1, 99);
  theDOMElement.setAttribute(tempStr, tempStr1);

  XMLString::transcode(transportationTypeStr.c_str (), tempStr, 99);
  if (transportationType)
  {
    strcpy (buf, "best_effort");
  }
  else
  {
    strcpy (buf, "reliable");
  }
  XMLString::transcode(buf, tempStr1, 99);
  theDOMElement.setAttribute(tempStr, tempStr1);
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::setStatusOwned(GeRtiFactory::GeRtiHandle const &theFederate)
{
  GERTICO::HandleSet::iterator itFederate;
  GERTICO::HandleSetMap::iterator itRegionFederate;

  federate = theFederate;
  orderType = orderTypeDefault;
  transportationType = transportationTypeDefault;

  if (theFederate)
  {
    GERTICO::HandleSet::iterator itPreviousOwner;
    status = owned;
    removeAcquiringFederate(theFederate);
    itPreviousOwner = previousOwners.find(theFederate);
    if (itPreviousOwner == previousOwners.end())
    {
      previousOwners.insert(theFederate);
    }
    else
    {
      clearFederateRegions(theFederate);
      return;
    }
  }
  else
  {
    status = unowned;
  }

  // If the federate has a region for this attribute, assume it is still good.
  for (itRegionFederate = regionFederates.begin(); itRegionFederate != regionFederates.end(); itRegionFederate++)
  {
    GERTICO::HandleSet *federatesPtr;
    federatesPtr = &itRegionFederate->second;
    itFederate = federatesPtr->find(theFederate);
    if (itFederate != federatesPtr->end())
    {
      return;
    }
  }

  itRegionFederate = regionFederates.find(0);
  if (itRegionFederate != regionFederates.end())
  {
    GERTICO::HandleSet *federatesPtr;
    federatesPtr = &itRegionFederate->second;
    federatesPtr->insert(theFederate);
  }
  else
  {
    GERTICO::HandleSet federates;
    federates.insert(theFederate);
    regionFederates[0] = federates;
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::setStatusAcquired(void)
{
  status = acquired;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::setStatusAcquiring(void)
{
  status = acquired;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::setStatusDivestConfirm(void)
{
  status = divestConfirm;
}
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::setStatusDivesting(void)
{
  status = divesting;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::setStatusFlag(GERTICO::AttributeStatus const &theStatus)
{
  status = theStatus;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::setStatusUnowned(void)
{
  status = unowned;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::setRequested ()
{
  isRequested = true;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
bool GERTICO::AttributeInfo::testRequested ()
{
  return isRequested;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::unsetRequested ()
{
  isRequested = false;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
bool GERTICO::AttributeInfo::testRegion(GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &theRegion)
{
  GERTICO::HandleSet::iterator itFederate;
  GERTICO::HandleSetMap::iterator itRegionFederate;

  itRegionFederate = regionFederates.find(theRegion);
  if (itRegionFederate != regionFederates.end())
  {
    GERTICO::HandleSet *federatesPtr;
    federatesPtr = &itRegionFederate->second;
    itFederate = federatesPtr->find(theFederate);
    if (itFederate != federatesPtr->end())
    {
      return true;
    }
  }

  return false;
}
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::AttributeInfo::unsetFederate (GeRtiFactory::GeRtiHandle const &theFederate)
{
  if (federate == theFederate)
  {
    federate = 0;
    if (status == owned)
    {
      status = unowned;
    }
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::PubAttributeDB::PubAttributeDB (void)
{
  started = false;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::PubAttributeDB::~PubAttributeDB (void)
{
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
bool GERTICO::PubAttributeDB::getStarted (void)
{
  return started;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::PubAttributeDB::setStarted (bool const &theBool)
{
  started = theBool;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::RegisteredObject::RegisteredObject(GeRtiFactory::GeRtiHandle const &theClass, GeRtiFactory::GeRtiHandle const &theObjectId, std::wstring const &theObjectName)
{
  myId = theObjectId;
  myName = theObjectName;
  myClass = theClass;
  init ();
}


// ---------------------------------------------------------------------------
// Used in LRC for register object instance
// ---------------------------------------------------------------------------
GERTICO::RegisteredObject::RegisteredObject (GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &theClass, GeRtiFactory::GeRtiHandle const &theObjectId, std::wstring const &theObjectName, GERTICO::HandleSet &theObjectAttributes, GERTICO::AttributeDatumMap &theAttributeDatumMap)
{
  GERTICO::AttributeInfo *attributeInfo;
  GERTICO::AttributeDatumMap::iterator itAttributeDatumMap;
  GERTICO::AttributeMap::iterator itAttributeMap;
  GERTICO::HandleSet::iterator iH;

  myId = theObjectId;
  myName = theObjectName;

  for (itAttributeDatumMap = theAttributeDatumMap.begin(); itAttributeDatumMap != theAttributeDatumMap.end(); itAttributeDatumMap++)
  {
    GERTICO::AttributeInfo* info = new GERTICO::AttributeInfo (theFederate, unowned, itAttributeDatumMap->second.theOrderType, itAttributeDatumMap->second.theTransportationType);
    attributes[itAttributeDatumMap->first] = info;
  }

  for (iH = theObjectAttributes.begin (); iH != theObjectAttributes.end (); iH++)
  {
    itAttributeMap = attributes.find(*iH);
    if (itAttributeMap != attributes.end())
    {
      attributeInfo = itAttributeMap->second;
      attributeInfo->setStatusOwned(theFederate);
    }
  }

  myClass = theClass;
  init();
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::RegisteredObject::RegisteredObject (GeRtiFactory::GeRtiHandle const &theFederate, GERTICO::ClassDescr &theClassDescr, GeRtiFactory::GeRtiHandle const &theObjectId, std::wstring const &theObjectName, GERTICO::HandleSet &theAttributesPub)
{
  GERTICO::AttributeInfo *attributeInfo;
  GERTICO::AttributeMap::iterator itAttributeMap;
  GERTICO::HandleSet attributeAll;
  GERTICO::HandleSet::iterator iH;
  GERTICO::Item *currItem;

  myId = theObjectId;
  myName = theObjectName;

  theClassDescr.getAttributes(attributeAll);

  for (iH = attributeAll.begin (); iH != attributeAll.end (); iH++)
  {
    currItem = theClassDescr.getClassItem (*iH);
    GERTICO::AttributeInfo* info = new GERTICO::AttributeInfo (0, unowned, currItem->getOrdering(), currItem->getTransportation());
    attributes[*iH] = info;
  }

  for (iH = theAttributesPub.begin (); iH != theAttributesPub.end (); iH++)
  {
    itAttributeMap = attributes.find(*iH);
    if (itAttributeMap != attributes.end())
    {
      attributeInfo = itAttributeMap->second;
    }
    attributeInfo->setStatusOwned(theFederate);
  }

  myClass = theClassDescr.getId ();
  init ();
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::RegisteredObject::~RegisteredObject ()
{
  // delete all attributes
  for (GERTICO::AttributeMap::iterator iA = attributes.begin();
       iA != attributes.end();
       iA = attributes.begin())
  {
    delete iA->second;
    attributes.erase(iA);
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::addAttribute (GeRtiFactory::GeRtiHandle const &theAttributeId, GERTICO::AttributeInfo *theAttributeInfo)
{
  attributes[theAttributeId] = theAttributeInfo;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::addAttributesDefaultRegion(GeRtiFactory::GeRtiHandle const &theFederate, GERTICO::HandleSet &theAttributePub)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::HandleSet::iterator itAttributeSet;

  for (itAttributeSet = theAttributePub.begin(); itAttributeSet != theAttributePub.end(); itAttributeSet++)
  {
    ai = getAttribute(*itAttributeSet);
    ai->addRegion(theFederate, 0);
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::addAttributesRegion(GeRtiFactory::GeRtiHandle const &theFederate, GERTICO::HandleSet &theAttributes, GeRtiFactory::GeRtiHandle const &theRegion)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator itAttributeMap;
  GERTICO::HandleSet regions;
  GERTICO::HandleSet::iterator itAttribute;
  GERTICO::HandleSet::iterator itRegion;
  bool gotObjectRegionPair = false;

  // Delete any old object/region relationships in the group of associations.
print();
  clearRegion(theFederate, theRegion);
print();

  for (itAttribute = theAttributes.begin(); itAttribute != theAttributes.end(); itAttribute++)
  {
    itAttributeMap = attributes.find(*itAttribute);
    if (itAttributeMap != attributes.end ())
    {
      ai = itAttributeMap->second;
      ai->addRegion(theFederate, theRegion);
    }
  }
print();
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::addAttributesRegions(GeRtiFactory::GeRtiHandle const &theFederate, GERTICO::HandleSetMap &theAttRegMap)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator iAttribute;
  GERTICO::HandleSet regions;
  GERTICO::HandleSet::iterator itRegion;
  GERTICO::HandleSetMap::iterator itAttRegMap;

  // Get a map of regions involved.
  for (itAttRegMap = theAttRegMap.begin(); itAttRegMap != theAttRegMap.end(); itAttRegMap++)
  {
    for (itRegion = itAttRegMap->second.begin(); itRegion != itAttRegMap->second.end(); itRegion++)
    {
      regions.insert(*itRegion);
    }
  }

  // Delete any old object/region relationships in the group of associations.
  for (itRegion = regions.begin(); itRegion != regions.end(); itRegion++)
  {
    clearRegion(theFederate, *itRegion);
  }

  for (itAttRegMap = theAttRegMap.begin(); itAttRegMap != theAttRegMap.end(); itAttRegMap++)
  {
    iAttribute = attributes.find(itAttRegMap->first);
    if (iAttribute != attributes.end ())
    {
      ai = iAttribute->second;
      for (itRegion = itAttRegMap->second.begin(); itRegion != itAttRegMap->second.end(); itRegion++)
      {
        ai->addRegion(theFederate, *itRegion);
      }
    }
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::cancelPendingAcquisitions (GeRtiFactory::GeRtiHandle const &theFederate)
{
  GERTICO::AttributeInfo *attributeInfo;
  GERTICO::AttributeMap::iterator itA;

  for (itA = attributes.begin (); itA != attributes.end (); itA++)
  {
    attributeInfo = itA->second;
    if (attributeInfo->beingAcquired ())
    {
      if (attributeInfo->testIfFederateIsAcquiring (theFederate))
      {
        attributeInfo->removeAcquiringFederate (theFederate);
        attributeInfo->setStatusFlag(owned);
      }
    }
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::changeAttributeOrderType (GeRtiFactory::Handles const &theAttributes, GeRtiFactory::GeRtiHandle const &theOrderType)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator iAttribute;
  CORBA::ULong i;
  CORBA::ULong len;

  len = theAttributes.length ();
  for (i = 0; i < len; i++)
  {
    iAttribute = attributes.find (theAttributes[i]);
    if (iAttribute != attributes.end ())
    {
      ai = iAttribute->second;
      ai->changeOrderType (theOrderType);
    }
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::changeAttributeTransportationType (GeRtiFactory::Handles const &theAttributes, GeRtiFactory::GeRtiHandle const &theTransportationType)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator iAttribute;
  CORBA::ULong i;
  CORBA::ULong len;

  len = theAttributes.length ();
  for (i = 0; i < len; i++)
  {
    iAttribute = attributes.find (theAttributes[i]);
    if (iAttribute != attributes.end ())
    {
      ai = iAttribute->second;
      ai->changeTransportationType (theTransportationType);
    }
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::checkOwnershipAcquisitionPending (GeRtiFactory::GeRtiHandle const &theFederate, GERTICO::HandleSet &theAttributes, GeRtiFactory::GeRtiHandle const &thePrivilegeToDeleteId)
{
  CORBA::WChar *wChar = L"";
  GERTICO::AttributeInfo *attributeInfo;
  GERTICO::AttributeMap::iterator itA;
  GERTICO::HandleSet::iterator itHS;
  CORBA::ULong ul;

  for (itA = attributes.begin (); itA != attributes.end (); itA++)
  {
    ul = itA->first;
    if (itA->first == thePrivilegeToDeleteId)
    {
      continue;
    }
    attributeInfo = itA->second;
    itHS = theAttributes.find (itA->first);
    if (itHS != theAttributes.end ())
    {
      // Not to be published.
/* For IEEE logic relevant
      if (attributeInfo->ownedByFederate (theFederate))
      {
        if (attributeInfo->beingAcquired ())
        {
          throw GeRtiFactory::OwnershipAcquisitionPending ();
        }
      }
*/
      if (attributeInfo->testIfFederateIsAcquiring (theFederate))
      {
        if (attributeInfo->beingAcquired ())
        {
          throw GeRtiFactory::OwnershipAcquisitionPending(wChar);
        }
      }
    }
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::clearRegion(GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &theRegion)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator iAttribute;

  for (iAttribute = attributes.begin(); iAttribute != attributes.end (); iAttribute++)
  {
    ai = iAttribute->second;
    ai->clearFederateRegion(theFederate, theRegion);
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::delRegion (GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &theRegion)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator iAttribute;

  for (iAttribute = attributes.begin(); iAttribute != attributes.end (); iAttribute++)
  {
    ai = iAttribute->second;
    ai->delRegion(theFederate, theRegion);
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getAllRegions(GERTICO::HandleSet &theRegions)
{
  GERTICO::HandleSet regions;
  GERTICO::HandleSet::iterator itRegion;
  GERTICO::HandleSet::iterator itR;
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator iAttribute;

  theRegions.clear();
  for (iAttribute = attributes.begin(); iAttribute != attributes.end (); iAttribute++)
  {
    ai = iAttribute->second;
    ai->getAllRegions(regions);
    for (itRegion = regions.begin(); itRegion != regions.end(); itRegion++)
    {
      itR = theRegions.find(*itRegion);
      if (itR == theRegions.end())
      {
        theRegions.insert(*itRegion);
      }
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getAttributeIds(GERTICO::HandleSet &theAttributes)
{
  GERTICO::AttributeMap::iterator iAttribute;

  theAttributes.clear();

  for (iAttribute = attributes.begin(); iAttribute != attributes.end (); iAttribute++)
  {
    theAttributes.insert(iAttribute->first);
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getDefaultRegionAtts(GERTICO::HandleSet &theAttributes)
{
  GERTICO::AttributeInfo *attributeInfo;
  GERTICO::AttributeMap::iterator iAttribute;
  GeRtiFactory::GeRtiHandle federate;

  theAttributes.clear();
  for (iAttribute = attributes.begin(); iAttribute != attributes.end (); iAttribute++)
  {
    attributeInfo = iAttribute->second;
    federate = attributeInfo->getFederate();
    if (attributeInfo->testRegion(federate, 0))
    {
      theAttributes.insert(iAttribute->first);
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::AttributeInfo* GERTICO::RegisteredObject::getAttribute (GeRtiFactory::GeRtiHandle theAttribute)
  throw (GeRtiFactory::AttributeNotDefined)
{
  CORBA::WChar *wChar = L"";
  GERTICO::AttributeMap::iterator iAttribute;
  iAttribute = attributes.find (theAttribute);
  if (iAttribute == attributes.end())
  {
    throw GeRtiFactory::AttributeNotDefined(wChar);
  }
  return iAttribute->second;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GeRtiFactory::GeRtiHandle GERTICO::RegisteredObject::getClassId (void) const
{
  return myClass;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getFederateObjectAttributes(GeRtiFactory::GeRtiHandle const &theFederate, GERTICO::HandleSet &theAttributes, GeRtiFactory::GeRtiHandle const &theRegion)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator iAttribute;

  for (iAttribute = attributes.begin(); iAttribute != attributes.end (); iAttribute++)
  {
    ai = iAttribute->second;
    if (ai->testRegion (theFederate, theRegion))
    {
      theAttributes.insert (iAttribute->first);
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GeRtiFactory::GeRtiHandle GERTICO::RegisteredObject::getId (void)
{
  return myId;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getName(std::wstring &theObjectName)
{
  theObjectName = myName;
}

// ---------------------------------------------------------------------------
// Use ONLY when the publisher is publishing in the default region.
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getNotFederateObjectAttributes(GeRtiFactory::GeRtiHandle const &theFederate, GERTICO::HandleSet &theAttributes)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator iAttribute;
  GeRtiFactory::GeRtiHandle otherFederate;

  theAttributes.clear();

  for (iAttribute = attributes.begin(); iAttribute != attributes.end (); iAttribute++)
  {
    ai = iAttribute->second;
    otherFederate = ai->getFederate();
    if (otherFederate != theFederate)
    {
      if (ai->testRegion(otherFederate, 0))
      {
        theAttributes.insert(iAttribute->first);
      }
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getOwnedAttributes (GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &privilegeToDeleteId, GERTICO::HandleSet &theAttributes, bool const &needPrivilegeToDelete)
{
  theAttributes.clear();
  for (GERTICO::AttributeMap::iterator iA = attributes.begin(); iA != attributes.end(); iA++)
  {
    if (iA->second->ownedByFederate(theFederate))
    {
      if (iA->first == privilegeToDeleteId)
      {
        if (needPrivilegeToDelete == false)
        {
          continue;
        }
      }
      theAttributes.insert(iA->first);
    }
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getOwner(GeRtiFactory::GeRtiHandle &theOwner, GeRtiFactory::GeRtiHandle const &privilegeToDeleteId)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator iAttribute;

  iAttribute = attributes.find(privilegeToDeleteId);
  if (iAttribute != attributes.end())
  {
    ai = iAttribute->second;
    theOwner = ai->getFederate();
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getOwners(GERTICO::HandleSet &theOwners)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator itAttribute;
  GERTICO::HandleSet::iterator itOwner;
  GeRtiFactory::GeRtiHandle owner;

  theOwners.clear();

  for (itAttribute = attributes.begin(); itAttribute != attributes.end(); itAttribute++)
  {
    ai = itAttribute->second;

    ai->getOwner(owner);
    if (owner == 0)
    {
      continue;
    }
    itOwner = theOwners.find(owner);
    if (itOwner == theOwners.end())
    {
      theOwners.insert(owner);
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getFedRegionOwnedAtts(GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &theRegion, GERTICO::HandleSet &theAttributes)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator itAttribute;

  theAttributes.clear();

  for (itAttribute = attributes.begin(); itAttribute != attributes.end(); itAttribute++)
  {
    ai = itAttribute->second;

    if (ai->ownedByFederate(theFederate))
    {
      if (ai->testRegion(theFederate, theRegion))
      {
        theAttributes.insert(itAttribute->first);
      }
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getFedAttRegions(GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &theAttributeId, GERTICO::HandleSet &theRegions)
{
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator iAttribute;

  iAttribute = attributes.find(theAttributeId);
  if (iAttribute != attributes.end ())
  {
     ai = iAttribute->second;
     ai->getFedRegions(theFederate, theRegions);
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::getUnownedObjectAttributes(GeRtiFactory::GeRtiHandle const &theFederate, GERTICO::HandleSet &theAttributes)
{
  theAttributes.clear();
  for (GERTICO::AttributeMap::iterator iA = attributes.begin(); iA != attributes.end(); iA++)
  {
    if (iA->second->ownedByFederate(theFederate) == false)
    {
      theAttributes.insert(iA->first);
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::init (void)
{
  attributeStr = "attribute";
  attributesStr = "attributes";
  classStr = "class";
  idStr = "id";
  nameStr = "name";
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::loadAttInfoMap(AttInfoMap &theAttInfoMap)
{
  GERTICO::AttInfo *currAttInfo;
  GERTICO::AttInfoMap::iterator itAI;
  GERTICO::AttributeInfo *ai;
  GERTICO::HandleSet::iterator itRegion;

  for (itAI = theAttInfoMap.begin(); itAI != theAttInfoMap.end(); itAI++)
  {
    currAttInfo = &itAI->second;
    ai = new GERTICO::AttributeInfo();
    ai->setStatusOwned(currAttInfo->federate);
// XXX    ai->acquiringFederate = currAttInfo->acquiringFederate;
    for (itRegion = currAttInfo->regions.begin(); itRegion != currAttInfo->regions.end(); itRegion++)
    {
      ai->addRegion(currAttInfo->federate, *itRegion);
    }
    switch (currAttInfo->getStatus())
    {
      case 0:
      {
        ai->setStatusFlag(undefined);
        break;
      }
      case 1:
      {
        ai->setStatusFlag(unowned);
        break;
      }
      case 2:
      {
        ai->setStatusFlag(owned);
        break;
      }
      case 3:
      {
        ai->setStatusFlag(acquiring);
        break;
      }
      case 4:
      {
        ai->setStatusFlag(acquired);
        break;
      }
      case 5:
      {
        ai->setStatusFlag(divesting);
        break;
      }
      case 6:
      {
        ai->setStatusFlag(divestConfirm);
        break;
      }
      default:
      {
        ai->setStatusFlag(undefined);
        break;
      }
    }
    ai->changeOrderType (currAttInfo->orderType);
    ai->changeTransportationType (currAttInfo->transportationType);

    attributes[itAI->first] = ai;
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
bool GERTICO::RegisteredObject::ownsAnyAttributeInstances (GeRtiFactory::GeRtiHandle const &theFederate)
{
  GERTICO::AttributeInfo *info;
  GERTICO::AttributeMap::iterator itA;

  for (itA = attributes.begin (); itA != attributes.end (); itA++)
  {
    // test if theFederate owns any instance attribute
    info = itA->second;

    // Check if the federate owns the instance attribute.
    if (info->ownedByFederate (theFederate))
    {
      return true;
    }
  }

  return false;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
bool GERTICO::RegisteredObject::ownsAnyAttributeInstancesNoPriv (GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &thePrivilegeToDeleteId)
{
  GERTICO::AttributeInfo *info;
  GERTICO::AttributeMap::iterator itA;
  bool noPriv = true;

  itA = attributes.find (thePrivilegeToDeleteId);
  if (itA != attributes.end ())
  {
    info = itA->second;

    if (info->ownedByFederate (theFederate))
    {
      // Has privilege to delete.
      noPriv = false;
    }
  }

  for (itA = attributes.begin (); itA != attributes.end (); itA++)
  {
    // test if theFederate owns any instance attribute
    info = itA->second;

    // Skip the privilege to delete attribute.
    if (itA->first == thePrivilegeToDeleteId)
    {
      continue;
    }

    // Check if the federate owns the instance attribute.
    if (info->ownedByFederate (theFederate))
    {
      if (noPriv)
      {
        // Does not have privilege to delete.
        return true;
      }
    }
  }

  return false;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::print ()
{
/*
  std::cout << "ObjectId " << myId << std::endl;
  GERTICO::AttributeMap::iterator iAttribute;
  for (iAttribute = attributes.begin(); iAttribute != attributes.end(); iAttribute++)
  {
    std::cout << "Attribute " << iAttribute->first
         << ", status = " << iAttribute->second->getStatus()
         << ", federate = " << iAttribute->second->getFederate ()
   << std::endl;
    iAttribute->second->print();
  }
*/
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::restore (DOMElement &theDOMElement)
{
  GERTICO::AttributeInfo *currAttributeInfo;
  DOMNode *child;
  DOMNode *subChild;
  char *tmpChar;
  unsigned long tmpID;

  // Restore the object attributes,
  for (child = theDOMElement.getFirstChild(); child != 0; child = child->getNextSibling())
  {
    if (child->getNodeType() == DOMNode::ELEMENT_NODE)
    {
      if (XMLString::compareString(child->getNodeName(),XMLString::transcode (attributesStr.c_str ())) == 0)
      {
        for (subChild = child->getFirstChild(); subChild != 0; subChild = subChild->getNextSibling())
        {
          if (subChild->getNodeType() == DOMNode::ELEMENT_NODE)
          {
            if (XMLString::compareString(subChild->getNodeName(),XMLString::transcode (attributeStr.c_str ())) == 0)
            {
              tmpChar = XMLString::transcode (((DOMElement *)subChild)->getAttribute (XMLString::transcode (idStr.c_str ())));
              sscanf (tmpChar, "%lu", &tmpID);
              currAttributeInfo = new GERTICO::AttributeInfo ();
              currAttributeInfo->restore (*((DOMElement *)subChild));
              attributes[tmpID] = currAttributeInfo;
            }
          }
        }
      }
    }
  }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::save (DOMDocument &theDOMDocument, DOMElement &theDOMElement)
{
  GERTICO::AttributeMap::iterator itA;
  DOMElement* elemLevel1;
  DOMElement* elemLevel2;
  XMLCh tempStr[100];
  XMLCh tempStr1[100];
  char buf[128];
  std::string s;
  unsigned long ul;

  ul = sizeof(XMLCh);
  XMLString::transcode(classStr.c_str (), tempStr, 99);
  ul = myClass;
  sprintf (buf, "%lu", ul);
  XMLString::transcode(buf, tempStr1, 99);
  theDOMElement.setAttribute(tempStr, tempStr1);

  XMLString::transcode(nameStr.c_str (), tempStr, 99);
  GERTICO::Mapper::mapStringFromWstring(s, myName);
  strcpy (buf, s.c_str ());
  XMLString::transcode(buf, tempStr1, 99);
  theDOMElement.setAttribute(tempStr, tempStr1);

  XMLString::transcode(attributesStr.c_str (), tempStr, 99);
  elemLevel1 = theDOMDocument.createElement(tempStr);
  theDOMElement.appendChild(elemLevel1);

  for (itA = attributes.begin (); itA != attributes.end (); itA++)
  {
    XMLString::transcode(attributeStr.c_str (), tempStr, 99);
    elemLevel2 = theDOMDocument.createElement(tempStr);
    elemLevel1->appendChild(elemLevel2);

    XMLString::transcode(idStr.c_str (), tempStr, 99);
    ul = itA->first;
    sprintf (buf, "%lu", ul);
    XMLString::transcode(buf, tempStr1, 99);
    elemLevel2->setAttribute(tempStr, tempStr1);

    itA->second->save(theDOMDocument, *elemLevel2);
  }
}


// ---------------------------------------------------------------------------
// USE IN LRC ONLY
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObject::unownAttribute (GeRtiFactory::GeRtiHandle theFederate, GeRtiFactory::GeRtiHandle theAttribute)
  throw (GeRtiFactory::OwnershipAcquisitionPending)
{
  CORBA::WChar *wChar = L"";
  GERTICO::AttributeInfo *ai;
  GERTICO::AttributeMap::iterator iAttribute;

  iAttribute = attributes.find (theAttribute);
  if (iAttribute != attributes.end())
  {
    ai = iAttribute->second;
    if (ai->getFederate () == theFederate)
    {
      if ((ai->getStatus() == acquiring) || (ai->getStatus() == acquired))
//      if (ai->getStatus() == acquiring)
      {
        throw GeRtiFactory::OwnershipAcquisitionPending(wChar);
      }
      ai->setStatusUnowned();
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::RegisteredObjectsHolder::RegisteredObjectsHolder(void)
{
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::RegisteredObjectsHolder::~RegisteredObjectsHolder(void)
{
  clear();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::addObject(GeRtiFactory::GeRtiHandle const &theObjectId, GERTICO::RegisteredObject *theRegisteredObject, std::wstring const &theObjectName)
{
  // No duplicates allowed, so try object by name first!
  addObjectByName(theObjectName, theObjectId);
  pm.acquire();
  objects[theObjectId] = theRegisteredObject;
  pm.release ();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::addObjectByName(std::wstring const &theObjectName, GeRtiFactory::GeRtiHandle const &theObjectId)
      throw (GeRtiFactory::ObjectAlreadyRegistered)
{
  CORBA::WChar *wChar = L"";
  GERTICO::RegisteredObject* theObject;
  std::wstring s(theObjectName);

  GERTICO::Mapper::nameToLower(s);
  theObject = getObjectByName(s);
  if (theObject)
  {
    throw GeRtiFactory::ObjectAlreadyRegistered(wChar);
  }

  // A map by name for quick access.
  pm.acquire();
  objectsByName[s] = theObjectId;
  pm.release ();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::cancelPendingAcquisitions(GeRtiFactory::GeRtiHandle const &theFederate, GERTICO::HandleSet &theObjects)
{
  GERTICO::HandleSet::iterator itHS;
  GERTICO::RegisteredObject *obj;

  for (itHS = theObjects.begin(); itHS != theObjects.end(); itHS++)
  {
    try
    {
      obj = getObject(*itHS);
      obj->cancelPendingAcquisitions(theFederate);
    }
    catch(...)
    {
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::clear(void)
{
  GERTICO::ObjectMap::iterator itObjectMap;
  GERTICO::RegisteredObject *currRegisteredObject;

  pm.acquire();
  for (itObjectMap = objects.begin(); itObjectMap != objects.end(); itObjectMap = objects.begin())
  {
    currRegisteredObject = itObjectMap->second;
    objects.erase(itObjectMap);
    delete currRegisteredObject;
  }

  for (itObjectMap = deletedObjects.begin(); itObjectMap != deletedObjects.end(); itObjectMap = deletedObjects.begin())
  {
    currRegisteredObject = itObjectMap->second;
    deletedObjects.erase(itObjectMap);
    delete currRegisteredObject;
  }

  objectsByName.clear();
  pm.release ();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::delObject(GeRtiFactory::GeRtiHandle const &theObjectId)
{
  GERTICO::ObjectMap::iterator iO;
  GERTICO::RegisteredObject *registeredObject;
  std::wstring s;

  pm.acquire();
  iO = objects.find (theObjectId);
  if (iO != objects.end())
  {
    registeredObject = iO->second;
    registeredObject->getName(s);
    deletedObjects[theObjectId] = registeredObject;
    objects.erase(iO);
    delObjectByName(s);
  }
  pm.release ();
}

// ---------------------------------------------------------------------------
// NB. Lock pm before calling!
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::delObjectByName(std::wstring const &theObjectName)
{
  ObjByNameMap::iterator itOBN;
  std::wstring s(theObjectName);

  GERTICO::Mapper::nameToLower(s);
  itOBN = objectsByName.find(s);
  if (itOBN != objectsByName.end())
  {
    objectsByName.erase(itOBN);
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::RegisteredObject* GERTICO::RegisteredObjectsHolder::getObject(GeRtiFactory::GeRtiHandle const &theObject)
  throw (GeRtiFactory::ObjectNotKnown)
{
  CORBA::WChar *wChar = L"getObject";
  ObjectMap::iterator iObject;

  pm.acquire();
  iObject = objects.find(theObject);
  if (iObject == objects.end())
  {
    pm.release ();
    throw GeRtiFactory::ObjectNotKnown(wChar);
  }
  pm.release ();
  return iObject->second;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
GERTICO::RegisteredObject *GERTICO::RegisteredObjectsHolder::getObjectByName(std::wstring const &theName)
{
  ObjectMap::iterator itO;
  ObjByNameMap::iterator itOBN;
  GERTICO::RegisteredObject *currObject;
  std::wstring s(theName);
  unsigned long id;

  pm.acquire();
  GERTICO::Mapper::nameToLower(s);
  itOBN = objectsByName.find(s);
  if (itOBN != objectsByName.end ())
  {
    id = itOBN->second;
    itO = objects.find (id);
    if (itO != objects.end ())
    {
      currObject = itO->second;
      pm.release ();
      return currObject;
    }
  }
  pm.release ();

  return NULL;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::getObjectIds(GERTICO::HandleSet &theObjects)
{
  ObjectMap::iterator iObject;

  theObjects.clear();
  pm.acquire();
  for (iObject = objects.begin(); iObject != objects.end(); iObject++)
  {
    theObjects.insert(iObject->first);
  }
  pm.release ();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::getOwnedObjectIds (
  const GeRtiFactory::GeRtiHandle &theFederate,
  GERTICO::HandleSet &theObjects, GeRtiFactory::GeRtiHandle const &privilegeToDeleteId)
{
  pm.acquire();
  for (ObjectMap::iterator iObject = objects.begin(); iObject != objects.end(); iObject++)
  {
    GERTICO::RegisteredObject* obj = iObject->second;
    try
    {
      // test if theFederate owns privilige to delete attribute
      AttributeInfo* info = obj->getAttribute(privilegeToDeleteId);
      if ((info->getStatus() == owned) &&
          (info->getFederate () == theFederate))
      {
        theObjects.insert(iObject->first);
      }
    }
    catch (GeRtiFactory::AttributeNotDefined &)
    {
    }
  }  
  pm.release ();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
bool GERTICO::RegisteredObjectsHolder::ownsAnyAttributeInstances(GeRtiFactory::GeRtiHandle const &theFederate)
{
  GERTICO::ObjectMap::iterator iObject;
  GERTICO::RegisteredObject *obj;

  pm.acquire();
  for (iObject = objects.begin(); iObject != objects.end(); iObject++)
  {
    obj = iObject->second;

    if (obj->ownsAnyAttributeInstances(theFederate))
    {
      pm.release ();
      return true;
    }
  }
  pm.release ();

  return false;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
bool GERTICO::RegisteredObjectsHolder::ownsAnyAttributeInstancesNoPriv(GeRtiFactory::GeRtiHandle const &theFederate, GeRtiFactory::GeRtiHandle const &thePrivilegeToDeleteId)
{
  GERTICO::ObjectMap::iterator iObject;
  GERTICO::RegisteredObject *obj;

  pm.acquire();
  for (iObject = objects.begin(); iObject != objects.end(); iObject++)
  {
    obj = iObject->second;

    if (obj->ownsAnyAttributeInstancesNoPriv(theFederate, thePrivilegeToDeleteId))
    {
      pm.release ();
      return true;
    }
  }
  pm.release ();

  return false;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::registerObjectInstance(GeRtiFactory::GeRtiHandle const &theFederate, GERTICO::ClassDescr &theClassDescr, GeRtiFactory::GeRtiHandle const &theObjectId, std::wstring const &theObjectName, GERTICO::HandleSet &theAttributesPub)
{
  GERTICO::RegisteredObject *registeredObject;

  registeredObject = new GERTICO::RegisteredObject(theFederate, theClassDescr, theObjectId, theObjectName, theAttributesPub);
  addObject(theObjectId, registeredObject, theObjectName);
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::reserveObjectInstanceName(std::wstring const &theObjectInstanceName)
{
  std::set <std::wstring, cmpWstring>::iterator itReservedObjectName;
  std::wstring s(theObjectInstanceName);

  GERTICO::Mapper::nameToLower(s);
  itReservedObjectName = reservedObjectNames.find(s);
  if (itReservedObjectName != reservedObjectNames.end())
  {
    throw GeRtiFactory::IllegalName(L"name already reserved");
  }
  else
  {
    reservedObjectNames.insert(s);
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::restore(DOMElement &theDOMElement)
{
  DOMNode* child;
  GERTICO::RegisteredObject *currRegisteredObject;
  char *tmpChar;
  std::wstring s;
  unsigned long tmpCLASS;
  unsigned long tmpID;

  for (child = theDOMElement.getFirstChild(); child != 0; child = child->getNextSibling())
  {
    if (child->getNodeType() == DOMNode::ELEMENT_NODE)
    {
      if (XMLString::compareString(child->getNodeName(),XMLString::transcode ("object")) == 0)
      {
        tmpChar = XMLString::transcode (((DOMElement*)child)->getAttribute (XMLString::transcode (idStr.c_str ())));
        sscanf (tmpChar, "%lu", &tmpID);
        tmpChar = XMLString::transcode (((DOMElement*)child)->getAttribute (XMLString::transcode (classStr.c_str ())));
        sscanf (tmpChar, "%lu", &tmpCLASS);
        tmpChar = XMLString::transcode (((DOMElement*)child)->getAttribute (XMLString::transcode (nameStr.c_str ())));
        GERTICO::Mapper::mapWstringFromChar(s, tmpChar);
        currRegisteredObject = new GERTICO::RegisteredObject (tmpCLASS, tmpID, s);
        currRegisteredObject->restore (*((DOMElement *)child));
        addObject(tmpID, currRegisteredObject, s);
      }
    }
  }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
void GERTICO::RegisteredObjectsHolder::save(DOMDocument &theDOMDocument, DOMElement &theDOMElement)
{
  DOMElement* elemLevel1;
  ObjectMap::iterator itObjectMap;
  XMLCh tempStr[128];
  XMLCh tempStr1[128];
  char buf[128];
  unsigned long ul;

  pm.acquire();
  for (itObjectMap = objects.begin(); itObjectMap != objects.end(); itObjectMap++)
  {
    XMLString::transcode("object", tempStr, 99);
    elemLevel1 = theDOMDocument.createElement(tempStr);
    theDOMElement.appendChild(elemLevel1);

    XMLString::transcode(idStr.c_str(), tempStr, 99);
    ul = itObjectMap->first;
    sprintf(buf, "%lu", ul);
    XMLString::transcode(buf, tempStr1, 99);
    elemLevel1->setAttribute(tempStr, tempStr1);

    itObjectMap->second->save(theDOMDocument, *elemLevel1);
  }
  pm.release ();
}
